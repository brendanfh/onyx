package core.iter

use package core.intrinsics.onyx { __zero_value }

filter :: (it: Iterator($T), predicate: (T) -> bool) -> Iterator(T) {
    FoldIterator :: struct (T: type_expr) {
        iterator:  Iterator(T);
        predicate: (T) -> bool;
    }

    fold_iterator := new(#type FoldIterator(T));
    fold_iterator.iterator = it;
    fold_iterator.predicate = predicate;

    next :: ($T: type_expr, data: rawptr) -> (T, bool) {
        fi := cast(^FoldIterator(T)) data;

        value, cont := fi.iterator.next(fi.iterator.data);
        if cont {
            while !fi.predicate(value) {
                value, cont = fi.iterator.next(fi.iterator.data);
                if !cont do return value, false;
            }

            return value, true;
        } else {
            return value, false;
        }
    }

    close :: ($T: type_expr, data: rawptr) {
        fi := cast(^FoldIterator(T)) data;
        fi.iterator.close(fi.iterator.data);
        cfree(data);
    }

    return .{
        data  = fold_iterator,
        next  = #solidify next  { T=T },
        close = #solidify close { T=T },
    };
}

map :: (it: Iterator($T), transform: (T) -> $R) -> Iterator(R) {
    MapIterator :: struct (T: type_expr, R: type_expr) {
        iterator:  Iterator(T);
        transform: (T) -> R;
    }

    map_iterator := new(#type MapIterator(T, R));
    map_iterator.iterator = it;
    map_iterator.transform = transform;

    next :: ($T: type_expr, $R: type_expr, data: rawptr) -> (R, bool) {
        mi := cast(^MapIterator(T, R)) data;

        value, cont := mi.iterator.next(mi.iterator.data);
        if !cont do return value, false;

        return mi.transform(value), true;
    }

    close :: ($T: type_expr, $R: type_expr, data: rawptr) {
        mi := cast(^MapIterator(T, R)) data;
        mi.iterator.close(mi.iterator.data);
        cfree(data);
    }

    return .{
        data  = map_iterator,
        next  = #solidify next  { T=T, R=R },
        close = #solidify close { T=T, R=R },
    };
}

take :: (it: Iterator($T), count: u32) -> Iterator(T) {
    TakeIterator :: struct (T: type_expr) {
        iterator:  Iterator(T);
        remaining: u32;
    }

    take_iterator := new(#type TakeIterator(T));
    take_iterator.iterator = it;
    take_iterator.remaining = count;

    next :: ($T: type_expr, data: rawptr) -> (T, bool) {
        ti := cast(^TakeIterator(T)) data;
        if ti.remaining == 0 do return __zero_value(T), false;

        ti.remaining -= 1;
        return ti.iterator.next(ti.iterator.data);
    }

    close :: ($T: type_expr, data: rawptr) {
        ti := cast(^TakeIterator(T)) data;
        ti.iterator.close(ti.iterator.data);
        cfree(data);
    }

    return .{
        data  = take_iterator,
        next  = #solidify next  { T=T },
        close = #solidify close { T=T },
    };
}

fold :: (it: Iterator($T), initial_value: R, combine: (T, $R) -> R) -> R {
    for value: it {
        initial_value = combine(value, initial_value);
    }
    
    return initial_value;
}

to_array :: (it: Iterator($T), allocator := context.allocator) -> [..] T {
    array :: package core.array

    arr := array.make(T, allocator=allocator);
    for v: it do array.push(^arr, v);

    return arr;
}
